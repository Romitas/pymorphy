Руководство
===========

Использование
-------------

.. py:currentmodule:: pymorphy._morph

Подготовка
^^^^^^^^^^

Чтобы использовать морфологический анализатор, нужно сначала создать объект
класса :class:`pymorphy.Morph <Morph>`::

    from pymorphy import get_morph
    morph = get_morph('dicts/ru')

Аргументы :meth:`pymorphy.get_morph <get_morph>`:

* ``path`` - обязательный параметр, путь до папки с файлами;
* ``backend`` - используемое key-value хранилище ('sqlite' по умолчанию);
* ``cached`` - использовать ли кэш (True по умолчанию).

Можно также передавать любые аргументы конструктора
класса :class:`pymorphy.Morph <Morph>`.

.. note::

    Обратите внимание, все методы Morph ожидают, что строковые
    аргументы (в.т.ч. пустые или латинские, если используется pymorphy-speedups)
    - это unicode-строки. Кроме того, слова для обработки должны быть в верхнем
    регистре.

.. _resource-warning:
.. warning::

    Всегда старайтесь использовать единственный экземпляр анализатора.

    Объекты класса :class:`pymorphy.Morph <Morph>` требуют довольно много
    ресурсов для создания, не уничтожаются сборщиком мусора и не закрывают
    за собой файловые дескрипторы, поэтому постоянное создание
    анализаторов будет приводить к утечке ресурсов.



Получение информации о слове
^^^^^^^^^^^^^^^^^^^^^^^^^^^^

    >>> word = u'Вася'.upper()
    >>> info = morph.get_graminfo(word)[0]
    >>> print info['norm']
    ВАСЯ
    >>> print info['class']
    С
    >>> print info['info']
    мр,имя,ед,им
    >>> print info['method']
    lemma(ВАС).suffix(Я)

:meth:`Morph.get_graminfo` возвращает list всех возможных вариантов разбора
слова. Каждый вариант разбора - dict, в котором есть нормальная форма, часть
речи, грамматическая информация и служебные данные для отладки. См. также
:doc:`ref/gram_info_ru`.


Получение нормальных форм
^^^^^^^^^^^^^^^^^^^^^^^^^

    >>> morph.normalize(u'БУТЯВКАМ')
    set(u'БУТЯВКА')

:meth:`Morph.normalize` возвращает множество (set) всех возможных нормальных
форм слова.

Склонение
^^^^^^^^^

    >>> morph.inflect_ru(u'БУТЯВКА', u'дт,мн')
    БУТЯВКАМ

:meth:`Morph.inflect_ru` возвращает слово в форме, которая соответствует
переданной и меньше всего отличается от исходной. В случае, если такую форму
найти не удается, возвращается исходное слово. См. также
:doc:`ref/gram_info_ru`.

Постановка во множественное число
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

Простое::

    >>> morph.pluralize_ru(u'БУТЯВКЕ')
    БУТЯВКАМ

Согласованное с цифрой::

    >>> morph.pluralize_inflected_ru(u'ПОПУГАЙ', 1)
    ПОПУГАЙ
    >>> morph.pluralize_inflected_ru(u'ПОПУГАЙ', 2)
    ПОПУГАЯ
    >>> morph.pluralize_inflected_ru(u'ПОПУГАЙ', 38)
    ПОПУГАЕВ

См. :meth:`Morph.pluralize_ru`, :meth:`Morph.pluralize_inflected_ru`.

.. _django-integration:

Интеграция с django
-------------------

Настройка
^^^^^^^^^

1. Добавляем ``'pymorphy'`` в ``INSTALLED_APPS``.

2. Описываем в settings.py установленные словари::

        PYMORPHY_DICTS = {
            'ru': { 'dir': '/usr/share/pymorphy/ru' },
        }

   более сложный пример::

        PYMORPHY_DICTS = {
            'ru': {
                'dir': os.path.join([PROJECT_DIR, 'files', 'dicts']),
                'backend': 'cdb',
                'use_cache': False,
            },
        }

   Параметры:

   * ``dir`` - обязательный параметр, путь до папки с файлами;
   * ``backend`` - используемое key-value хранилище ('sqlite' по умолчанию);
   * ``use_cache`` - использовать ли кэш (True по умолчанию).

Получение экземпляра анализатора для ручного использования
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

В случае, когда настроена интеграция pymorphy с django,
экземпляр анализатора следует получать следующим образом::

    from pymorphy.django_conf import default_morph as morph

Не стоит получать экземпляр анализатора через
:meth:`pymorphy.get_morph <get_morph>` во вьюхах (или еще где-то на каждый
запрос) - это приведет к утечке ресурсов.

Шаблонные фильтры
^^^^^^^^^^^^^^^^^

Фильтры подключаются следующей командой::

    {% load pymorphy_tags %}

.. _inflect-filter:

inflect
#######

Меняет грамматическую форму каждого слова на указанную в параметрах.
Про доступные параметры можно почитать тут: :ref:`parameter-format`

Пример:

.. code-block:: django

   {# в переменной city "Нижний Новгород" #}

   {% load pymorphy_tags %}
   Мы начали работу в {{ city|inflect:"пр" }}!

   {# выведет "Мы начали работу в Нижнем Новгороде!" #}


Пример с несклоняемой частью

.. code-block:: django

   {% load pymorphy_tags %}

   Не осталось у нас {{ "лошадь [[Пржевальского]]"|inflect:"рд,мн" }}.

   {# выведет "Не осталось у нас лошадей Пржевальского" #}

.. _inflect_marked-filter:

inflect_marked
##############

Идентичен фильтру inflect за исключением того, что противоположным образом
трактует [[ ]]

.. code-block:: django

   {% load pymorphy_tags %}
   Не осталось у нас {{ "[[лошадь]] Пржевальского"|inflect_marked:"рд,мн" }}.

   {# выведет "Не осталось у нас лошадей Пржевальского" #}

.. _plural-filter:

plural
######

Ставит слово в форму, которая согласуется с заданным числом (1 попугай,
2 попугая, 5 попугаев).

.. code-block:: django

   {% load pymorphy_tags %}

   {# в переменной num число попугаев (пусть = 38) #}
   На дереве {{ num }} {{ "попугай"|plural:num }}.
   {# выведет "На дереве 38 попугаев." #}

   {# в переменной animal - "лошадь" #}
   А еще есть {{ num }} {{ animal|plural:num }}.
   {# выведет "А еще есть 38 лошадей." #}

Фильтры :ref:`inflect-filter` и :ref:`plural-filter` не склоняют все,
что заключено в двойные квадратные скобки. Фильтр :ref:`inflect_marked-filter`
наоборот, работает только с тем, что в двойных квадратных скобках.

Можно указать другие разделители (обязательно 2х-символьные),
определив в settings.py переменные ``PYMORPHY_MARKER_OPEN`` и
``PYMORPHY_MARKER_CLOSE``.

.. note::

   Фильтры из pymorphy_tags стараются сохранить написание больших-маленьких
   букв (обрабатываются варианты "ВСЕ СЛОВО БОЛЬШИМИ", "С заглавной",
   "все маленькими").

   Если по какой-то причине смена формы не удалась, возвращают исходную строку.


Выбор хранилища для словарей
----------------------------

pymorphy поддерживает разные форматы для хранения словарей. Формат по
умолчанию - sqlite. Этот формат поддерживается везде, не требует настройки, но,
одновременно, является самым медленным.

Более быстрые альтернативы - cdb, bsddb, tcb, tch - имеют свои плюсы и минусы,
отличаются друг от друга способом установки, скоростью и потреблением памяти.

Самый быстрый вариант - это загрузка словарей целиком в память (через
pickle backend). В этом случае нет задержек на чтение данных с диска и
преобразование их в нужный формат (все читается сразу), но
расходуется 200-300Мб оперативной памяти. В этот формат словари можно
преобразовать с помощью скрипта encode_dicts.py (лежит в репозитории с исходным
кодом).

Более подробно обо всем этом можно узнать тут: :ref:`supported-storages`.

Скорость
--------

С pymorphy можно ожидать разбор нескольких сотен русских слов в секунду
"из коробки". После дополнительной настройки можно получить производительность в
несколько тысяч слов в секунду.

Этой скорости достаточно для многих задач (например, для различных экспериментов
и задач, связанных с web), но pymorphy в нынешнем виде, думаю, не подойдет,
если нужно быстро обрабатывать очень большие объемы данных. В этом случае
лучше использовать `lemmatizer <http://lemmatizer.org/>`_ или
`mystem <http://company.yandex.ru/technology/mystem/>`_.

У pymorphy нет цели быть быстрым, приоритет отдается качеству разбора и легкости
сопровождения. С учетом того, что это хобби-opensource-проект, код и алгоритмы
должны быть максимально простыми и понятными, чтобы облегчить внесение
изменений и доработку под конкретные задачи.

На данный момент pymorphy можно заставить работать быстрее несколькими способами:

* перейти на более быстрое хранилище (sqlite → cdb → pickle);
* отключить ненужные предсказатели;
* установить simplejson (для упрощения установки pymorphy его не требует и
  использует по умолчанию встроенный медленный модуль)::

      $ pip install simplejson

* поставить пакет `pymorphy-speedups <http://pypi.python.org/pypi/pymorphy-speedups>`_,
  который содержит авто-подключаемое Cython-расширение::

      $ pip install pymorphy-speedups

.. note::

    Для установки pymorphy-speedups и simplejson потребуются заголовочные файлы
    питона и среда с компилятором (как и для сборки любых других расширений).
